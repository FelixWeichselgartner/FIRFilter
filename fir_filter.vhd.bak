library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.mytypes_pkg.all;
use IEEE.MATH_REAL.ALL;

entity fir_filter is
  generic (

    coeffs    : my_array_t2 := (to_signed(1,N),to_signed(1,N),to_signed(1,N),to_signed(1,N),to_signed(1,N),to_signed(1,N),to_signed(1,N))-------------------------------------------------(0.0135,0.0785,0.2409,0.3344,0.2409,0.0785,0.0135)
  );
port (
	Reset:  in std_logic;
	Clk: 	in std_logic; 
	X:		in signed(N-1 downto 0);
	Y: 		out signed(N-1 downto 0)
);		
end entity fir_filter;	
architecture Behavioral of fir_filter is
component dff_n is
	port (
		Reset: in std_logic;
		Clk: in std_logic;
		d:	 in signed(N-1 downto 0);
		q:	 out signed(N-1 downto 0)
	);
end component dff_n;
signal s_coeff:		t_coeff;
signal s_mul:	 	t_mult;
signal q:			t_add;
signal s_add:		t_add;


begin
  	GEN: for i in 0 to Nsteps-1 generate
	   	s_coeff(i) <= coeffs(i);
	    s_mul(i)   <= resize(coeffs(i) * X,N);
   	end generate GEN;
   	GEN_ADD: for i in 1 to Nsteps-1 generate---------------------------------IF HERE?
	   	s_add(i) <= q(i-1)+s_mul(Nsteps-1-i);
   	end generate GEN_ADD;

	dff1 : dff_n port map (Clk,Reset,s_mul(6),q(0));
	dff2 : dff_n port map (Clk,Reset,s_mul(5),q(1));
	dff3 : dff_n port map (Clk,Reset,s_mul(4),q(2));
	dff4 : dff_n port map (Clk,Reset,s_mul(3),q(3));
	dff5 : dff_n port map (Clk,Reset,s_mul(2),q(4));
	dff6 : dff_n port map (Clk,Reset,s_mul(1),q(5));
	dff7 : dff_n port map (Clk,Reset,s_mul(0),q(6));

	p : process (Reset,Clk)
	  	begin                
	    if(rising_edge(Clk)) then
	      Y <= s_add(Nsteps-1);
	    end if;
	end process p;
end architecture Behavioral;


--Questions
--1 interpret real with fixed point how?
--2 reset should we just leave dff behaviour
--3 tb, how to verify correctness from simulation
--4 size after multiplication &/| sum?
--5 if inside generate